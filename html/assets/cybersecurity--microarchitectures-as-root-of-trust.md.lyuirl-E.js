import{_ as e,o as t,c as a,R as i}from"./chunks/framework.tzssv0c6.js";const n="/assets/image2.agZ46g9v.png",g=JSON.parse('{"title":"Microarchitectures as root of trust","description":"","frontmatter":{"title":"Microarchitectures as root of trust\\n","keywords":"harware, security, microarchitecture","lastUpdated":"2024-02-05T09:21:00.575Z","prev":{"text":"Integrity of hardware supply chains\\n","link":"/cybersecurity--integrity-of-hardware-supply-chains"},"next":false},"headers":[],"relativePath":"cybersecurity--microarchitectures-as-root-of-trust.md","filePath":"cybersecurity--microarchitectures-as-root-of-trust.md"}'),r={name:"cybersecurity--microarchitectures-as-root-of-trust.md"},o=i('<a target="_blank" href="https://doi.org/10.5281/zenodo.10875080"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.10875080.svg" alt="DOI" class="badge"></a><blockquote><p>While computing systems rely on hardware as a &quot;root-of-trust&quot; for security, new vulnerabilities exist that cannot be patched in software alone. Security verification and the development of defense mechanisms must be pursued at the microarchitectural hardware level, utilizing formal methods specifically tailored for security verification.</p></blockquote><h1 id="microarchitectures-as-root-of-trust-in-computing-systems-–-research-needs-in-formal-security-analysis" tabindex="-1">Microarchitectures as Root-of-Trust in Computing Systems – Research Needs in Formal Security Analysis <a class="header-anchor" href="#microarchitectures-as-root-of-trust-in-computing-systems-–-research-needs-in-formal-security-analysis" aria-label="Permalink to &quot;Microarchitectures as Root-of-Trust in Computing Systems – Research Needs in Formal Security Analysis&quot;">​</a></h1><p>by Wolfgang Kunz and Dominik Stoffel</p><p>System-on-Chips (SoCs) and embedded systems are ubiquitous in modern society. With their abundance of connectivity features they create a new attack surface for cyberattacks. Our trust in computing systems depends mainly on the provided safety and security features of the underlying computing hardware. Although the majority of the advanced security features, such as end-to-end encryption, are implemented at the software level, they rely on basic hardware primitives to deliver the intended functionalities. In common terminology, such hardware primitives form the “<em>root-of-trust”</em> of the computing system. They constitute a set of trusted functionalities to ensure the security of the system. Any security flaw in the hardware root-of-trust can affect virtually all applications deployed on the system.</p><p>Hardware systems are difficult or, in some cases, even impossible to patch, which exacerbates the challenge of dealing with hardware security flaws. Countless reports in recent years on system vulnerabilities at the hardware level, e.g., [1], [2], attest to the fact that hardware security flaws can pose a genuine threat to the overall system security. The Common Weakness Enumeration database (CWE) [3] has acknowledged this problem by including hardware vulnerabilities as a separate category of security weaknesses.</p><p>The role of hardware in system security is not limited to providing security-related features to support software functions. Weaknesses in the hardware design itself can introduce severe vulnerabilities to the computing system. At the microarchitectural level, these weaknesses mostly have two sources: the hardware circuit executing a security-critical software application may leak confidential information through side channels, in particular timing of the software execution [4], or (possibly very subtle) design bugs escape conventional verification procedures and cause security risks for the entire system.</p><p>David Patterson,<br> Keynote IEEE/ACM Design Automation Conference, 2018</p><p>This article explores using formal methods for verifying hardware security, a shift from the traditional software-centric approach. Historically, cybersecurity focused on software vulnerabilities, but the 2018 discovery of hardware-based attacks like Spectre and Meltdown, exploiting ISA-invisible side channels such as transient execution side channels (TES), revealed the limits of software-only defenses. Subsequent attacks (e.g., [3], [4]) have further challenged the effectiveness of existing solutions and underscore the need for more comprehensive hardware security strategies.</p><p>Martin Dixon, VP for Security at Intel, 2021</p><p>Today, re-establishing trust in the microarchitectures of computing systems has become one of the main goals in the computer industry and among chip makers. Microarchitectural descriptions at the Register Transfer Level (RTL) are the point of reference for sign-off verification before the tape-out of a chip for manufacturing. They typically serve as the <em>golden model</em> of an SoC and are the basis for all design refinements at lower levels as well as for manufacturing.</p><p>Security verification and the development of defense mechanisms at the microarchitectural level have become rapidly growing research fields. There is general conviction that the formidable patch-and-pray cycles can only be overcome if comprehensive security guarantees are already provided during design and before tape-out. Formal verification bears promise to provide such guarantees. However, currently available techniques are tailored towards general functional design aspects and suffer from severe limitations when targeting microarchitectural security and side channels.</p><h2 id="key-insights" tabindex="-1">Key insights <a class="header-anchor" href="#key-insights" aria-label="Permalink to &quot;Key insights&quot;">​</a></h2><ul><li><p>The immense attack surface exposed by microarchitectural security flaws and the vastness and diversity of SoC deployment domains necessitates extending formal methods from just functional correctness to systematic non-functional security verification. Research is vital to understand and formalize these diverse security risks and threats.</p></li><li><p>Conventional functional verification applied to individual design components cannot provide comprehensive security guarantees for extensive hardware systems interacting with software; vulnerabilities often arise from the integration of multiple components and specific hardware-software interactions.</p></li><li><p>The current solutions for mitigating security vulnerabilities often involve ad hoc processes, which require significant design alterations and necessitate communication with software developers. Moreover, while advanced security measures have been suggested to address timing side channels, they substantially escalate the manual design workload and introduce considerable hardware overhead, highlighting a pressing need for more refined, systematic, and comprehensive strategies.</p></li></ul><h2 id="key-recommendations" tabindex="-1">Key recommendations <a class="header-anchor" href="#key-recommendations" aria-label="Permalink to &quot;Key recommendations&quot;">​</a></h2><ul><li><p>Invest in research and development of tools for exhaustive security analysis of SoC microarchitectures. Invest in the formalization of microarchitectural threat models as targets for a new generation of non-functional formal verification methods.</p></li><li><p>Devise, implement and adopt new design and verification methodologies based on these new tools, pursuing verification-driven, secure-by-construction design providing system-wide threat coverage.</p></li><li><p>Contribute to open-source and public-domain initiatives like the RISC-V ecosystem to demonstrate use of the new tools and methodologies and to facilitate their widespread adoption and dissemination.</p></li></ul><h2 id="security-vulnerabilities" tabindex="-1">Security Vulnerabilities <a class="header-anchor" href="#security-vulnerabilities" aria-label="Permalink to &quot;Security Vulnerabilities&quot;">​</a></h2><p>Security analysis must address a wide spectrum of potential hardware vulnerabilities. At the microarchitectural hardware level, there are two main categories: <em>security-violating design bugs</em> and <em>microarchitectural timing side channels</em>.</p><p><em>Security-violating design bugs</em> are the subset of all design bugs that, besides violating the functional specification, violate a relevant security target. In principle, bugs can be detected by conventional functional verification. However, this requires the complete and correct specification of the entire design as well as of all its security mechanisms. Substantial effort is demanded from verification engineers to cover all security-relevant functional behaviors by a set of properties specified in a property specification language such as SVA (SystemVerilog Assertions). Even then, there may still be verification gaps remaining: security issues related to the communication between modules or to the interaction between hardware and firmware are easily missed [5].</p><p>A design that is bug-free may still be vulnerable to <em>side channels</em>. At the microarchitectural level, side channels are based on <em>timing</em>. Although a program may not have access rights to a certain set of data, depending on this data, one and the same program may behave slightly differently in terms of its own computation results, i.e., what data it stores in which registers and at which time points. These differences only affect the detailed timing of the microarchitectural implementation and have no impact at the level of the <em>instruction set architecture</em> (ISA), i.e., they do not affect the correct functioning of the program as observed by the programmer. However, if these subtle alterations of the program’s execution at the microarchitectural level are caused by secret data to which the program must not have access, this may open a “side channel”. An attacker, owning (and creating) such a program, may trigger and observe these alterations to infer secret information. This is called a “microarchitectural side channel attack”.</p><p>The following observation is key to classifying microarchitectural side channels and the corresponding verification targets (properties): In the conventional attack scenario the attacker process by itself is not capable of controlling both ends of a side channel. To steal secret information, it must interact with another process initiated by the system, the “victim process”, which manipulates the secret and “makes a noise”. Common defenses at the software level include constant-time encryption [6] and cache access pattern obfuscation [7]. They prohibit the information flow at the “sending end” of the channel, i.e., the one owned by the victim process.</p><p>Although securing encryption software against these attacks is challenging because it demands a deep understanding of microarchitectural details, in the past, the threat of microarchitectural side channels was generally perceived to be limited to a small set of software applications. This general intuition, however, was drastically changed by the discovery of <em>transient execution side channel (TES) attacks</em>. Even though they use similar channels for exfiltrating information, TES attacks are fundamentally different from classical microarchitectural side channels. TES attacks exploit side effects of transient instruction execution, a phenomenon not visible in the sequential execution semantics of the ISA. Transient execution occurs when the processor speculatively executes instructions ahead of time that it needs to roll back if the speculation turns out to be wrong. Such transient instruction execution may leak secret data through timing side channels and is the root cause for TES attacks. Without affecting the ISA-level results of the program, the attacker triggers transient executions of instructions that depend on secret data. In this way, the attacker does not rely on a vulnerability within a victim software to make a noise. In fact, the TES attacker controls both ends of the channel, the part that triggers the side effect and sends out the information as well as the part that observes it. This makes TES attacks more threatening than the earlier known timing side channels. In the TES scenario, a single user-level attacker program can establish a microarchitectural side channel leaking parts of the memory which are not accessed by any other program. Such HW covert channels not only can destroy the usefulness of encryption and secure authentication schemes but can steal data from essentially anywhere in the system. As a result, unlike classical side channel attacks, TES attacks threaten the overall security of the system and its root of trust.</p><p>Since the publication of the Spectre [8] and Meltdown [9] attacks in 2018, numerous new TES-based attacks have been discovered (e.g., MDS attacks [10], [11], [12]), speculative store bypass [13], speculative interference [14]), with many of them targeting a previously patched system (e.g., Fallout attack [10]), calling for new attention towards hardware security.</p><h2 id="needed-a-formalization-of-threat-models" tabindex="-1">Needed: A Formalization of Threat Models <a class="header-anchor" href="#needed-a-formalization-of-threat-models" aria-label="Permalink to &quot;Needed: A Formalization of Threat Models&quot;">​</a></h2><p>When considering both, the vast scope of the possible microarchitectural security threats, and the great variety of deployment domains for SoCs, it becomes apparent that the attack surface is huge. Such a challenge can only be met if formal methods are extended beyond traditional functional correctness checking to non-functional security verification. This must be done in a systematic way such that the relevant threats in their large diversity can be described, and many different use scenarios for computing systems can be covered. Research is needed to characterize security risks and to develop and formalize the threats. In other words, we need a <em>taxonomy of threat models</em>. A threat model for hardware captures the <em>security targets</em> for a system in combination with a <em>profile of the attackers</em>.</p><p>Security targets for hardware most commonly are requirements of <em>confidentiality</em> or <em>integrity</em>. <em>Confidentiality</em> of hardware is given if all information stored or processed in the system is protected against being retrieved by an unauthorized entity. <em>Integrity</em> means preventing an attacker from changing or influencing a part of the system that is specified as protected.</p><p>The attacker profile makes assumptions about how attackers can access the system and what methods they can use to exploit potential vulnerabilities of the system. For example, an attacker may access the system by running an unprivileged user process. Another threat model may consider access to the security-critical system through a third-party IP which is added to the system and which the attacker controls. Specific threat models are the basis for the specification of verifiable properties. The challenge consists in formulating these properties in such a way that a large spectrum of different threat models is covered by a manageable set of properties.</p><p>Figure 1 illustrates the space of threat models that must be analyzed for specifying verifiable properties. The points associated with important threat models are marked in green color. Firstly, it is meaningful to distinguish between security-violating functional bugs and non-functional vulnerabilities such as side channels. This is the blue dimension in the shown space.</p><p>Secondly, the vertical dimension (red color) of the cube in Figure 1 distinguishes between vulnerabilities that occur only in <em>cores</em> and those requiring a global analysis of the entire <em>System-on-Chip (SoC)</em>. For example, TESs, such as Spectre and Meltdown, only require an analysis of the core while the root cause of other types of timing side channels can be distributed over several locations of the SoC.</p><p>Thirdly, the horizontal axis of the cube separates threat models related to the security target of <em>confidentiality</em> from those related to <em>integrity</em>.</p><p>We give some examples of threat models related to specific points of the cube in Figure 1:</p><h4 id="threat-model-010" tabindex="-1">Threat Model 010 <a class="header-anchor" href="#threat-model-010" aria-label="Permalink to &quot;Threat Model 010&quot;">​</a></h4><ul><li><p><em>Security target:</em> Confidentiality of data in protected memory locations</p></li><li><p><em>Attacker Profile:</em> Attacker can run any program on the core with user-level privileges.</p></li><li><p><em>Class of vulnerabilities:</em> Transient Execution Side Channel in cores</p></li></ul><p>Note that several threat models can belong to each point in the space of Figure 1, for example:</p><h4 id="threat-model-101a" tabindex="-1">Threat Model 101a <a class="header-anchor" href="#threat-model-101a" aria-label="Permalink to &quot;Threat Model 101a&quot;">​</a></h4><ul><li><p><em>Security target:</em> Integrity of information and integrity of operation in security-critical parts of SoC</p></li><li><p><em>Attacker Profile:</em> Attacker controls a third-party IP which communicates with the security-critical SoC domain.</p></li><li><p>Class of vulnerabilities: Design bugs (insufficient protection mechanisms)</p></li></ul><h4 id="threat-model-101b" tabindex="-1">Threat Model 101b <a class="header-anchor" href="#threat-model-101b" aria-label="Permalink to &quot;Threat Model 101b&quot;">​</a></h4><ul><li><p><em>Security target:</em> Integrity of information and integrity of operation in security-<br> critical parts of SoC</p></li><li><p><em>Attacker Profile:</em> Attacker can inject faults by laser light anywhere in the SoC.</p></li><li><p><em>Class of vulnerabilities:</em> Design bugs (insufficient protection mechanisms)</p></li></ul><p>Hardware security engineers conduct threat analyses to create relevant threat models for specific designs and deployment domains. These models form the basis for verification engineers to define verification targets as formal properties, specified in languages like SVA. It&#39;s crucial to globally formalize threat models, aiming to cover a broad spectrum of vulnerabilities and attacker profiles, including &quot;unknown unknowns&quot;, i.e., yet undiscovered vulnerabilities. The overall goal is to create generic, re-usable verification IPs.</p><h2 id="needed-new-tools" tabindex="-1">Needed: New Tools <a class="header-anchor" href="#needed-new-tools" aria-label="Permalink to &quot;Needed: New Tools&quot;">​</a></h2><p>Late detection of hardware security flaws can incur tremendous costs, calling for <em>new functional verification</em> techniques specifically for hardware security. Rather than being exhaustive with respect to a complete functional design specification, the new tools must be <em>exhaustive</em> <em>with respect to a well-defined threat model</em> and deliver well-defined security guarantees. The new tools must be scalable and, at the same time, amenable to adoption by current industrial hardware design flows.</p><p>While conventional functional verification of a design, in principle, also avoids security-critical bug escapes, the manual effort for such an exercise is prohibitively large. The state-of-the-art flow for security verification based on functional property checking is shown in the left part of Figure 2. The targeted security features (Box II) typically result from a high-level, architectural perspective. The design specification is extended by an additional <em>functional</em> specification (Box III) of these security features which guides their integration into the RTL implementation. This is followed by functional verification procedures (Box IV. It turns out, however, that this classic approach is not always sufficient. Not only does conventional functional verification miss side channels, but also the abstract security requirements can be extremely difficult to map to functional specifications, requiring a detailed, microarchitectural understanding of security threats. Therefore, the specification itself (Box II) may fail to cover relevant aspects of the global threat model. Experience shows that, even when choosing security features conservatively, the conventional design process can miss subtle, yet hazardous security gaps and gives rise to the widely spread complaint about a never-ending “patch-and-pray” cycle.</p><p><img src="'+n+'" alt=""><em>Figure 2: Functional vs. Non-functional verification flow for security</em></p><p>Therefore, new approaches to formal hardware security verification are needed that target security properties directly. Such a flow is shown on the right side of Figure 2. Instead of developing a detailed (and error-prone) functional specification, this approach starts from the applicable threat model (Box I) and formalizes security requirements rather than detailed functional behaviors. This leads to specifying non-functional security properties (Box VI) which are orthogonal to conventional functional specifications. Since these properties directly target global security requirements without the need of a functional specification for the intended defense mechanisms, these methods have the potential to cover security breaches (both functional breaches and side channels) which are easily missed by the conventional approach. Both conventional solvers for functional verification as well as specialized solvers, such as [15], can serve as a basis to extend formal hardware verification for such non-functional targets (Box VII).</p><p>In addition to functional or explicit information leakages that violate the security requirements, implicit information flows through <em>timing side channels</em> must also be considered. This complicates the verification process significantly because the functional specification, which is untimed, cannot make such a requirement. Therefore, there is a lack of proper specification techniques for security against timing side channels.</p><p>New formal tools are needed which target the threats by timing side channels in a systematic way. This research can build upon initial successes in academia to detect transient execution side channels but must extend the scope to all other side channels relevant at the microarchitectural level. The new methods must be capable of handling different architectures ranging from simple in-order processors without speculation to out-of-order processors with speculation.</p><h2 id="needed-new-flows-and-methodologies" tabindex="-1">Needed: New Flows and Methodologies <a class="header-anchor" href="#needed-new-flows-and-methodologies" aria-label="Permalink to &quot;Needed: New Flows and Methodologies&quot;">​</a></h2><p>Running a single tool on a specific design or design component can never lead to global security guarantees formulated for a large hardware system and its interface with software. Instead, such guarantees must result from a security-driven flow that combines the results of different methods and tools across components and design layers. The needed extensions to today’s flows have a “horizontal” and a “vertical” dimension.</p><p>The horizontal dimension concerns the structural composition of hardware designs consisting of multiple interconnected modules. Many security issues are introduced into the system through the <em>integration</em> of these components, and a vulnerability in one component may only be exploited through its communication with other components. Detecting such vulnerabilities requires analyzing information flows across multiple components which is usually a computationally expensive task for formal verification techniques.</p><p>This calls for new scalable verification <em>methodologies</em> exploiting specific advantages of different methods to cover system-wide security for a given threat model. The new methodologies are required to combine the results of different tools to compose global guarantees on the entire system. Formal verification in such a setting can be based on sound abstraction techniques over different stages of the design flow.</p><p>The vertical dimension concerns the Hardware/Software Interface. Many hardware security issues are only exposed if they are triggered by a specific interaction between hardware and software. Formal verification of such mechanisms demands proper modeling of hardware/software interaction.</p><h2 id="needed-verification-driven-secure-by-construction-design" tabindex="-1">Needed: Verification-Driven/Secure-by-Construction Design <a class="header-anchor" href="#needed-verification-driven-secure-by-construction-design" aria-label="Permalink to &quot;Needed: Verification-Driven/Secure-by-Construction Design&quot;">​</a></h2><p>Experience in industry and academia shows that most SoC hardware designs suffer from numerous security flaws based on both microarchitectural timing side channels and functional design bugs. Fixing design bugs is usually an ad hoc process which solves the problem by making design changes and/or communicating possible restrictions for the software layer with the software developers. Fixing timing side channels is a more demanding procedure. Advanced security features have been proposed, such as those based on information flow tracking [16], [17], that promise effective measures against these vulnerabilities. However, this comes with significant costs: the manual RTL design effort increases drastically, and the new architectures come with a significant hardware overhead that so far has only been estimated based on abstract system simulations. Only a few RTL architectures with security guarantees for side channels have been proposed.</p><p>Clearly, research is needed to explore new security architectures at the RTL. Formal security analysis can make a major contribution to developing new design methodologies leading to new security architectures. Formal verification precisely and exhaustively determines <em>all</em> attack scenarios that are relevant under the specified threat model. This knowledge can be very valuable to i) determine the root causes of the security weakness and ii) to derive fixes that avoid excessive conservatism. Note that, without the knowledge of formal tools, current measures for security often employ “blanket fixes” that cover a large (but not fully understood) spectrum of weaknesses.</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><div class="info custom-block"><p class="custom-block-title">AUTHORS</p><p><strong>Wolfgang Kunz and Dominik Stoffel</strong> are professors in the Department of Electrical and Computer Engineering at University of Kaiserslautern, Germany.</p><p>Sponsored by the German Agentur für Innovation in der Cybersicherheit GmbH.</p></div><div class="info custom-block"><p class="custom-block-title">REFERENCES</p><p>[1]: S. J. Vicarte, M. Flanders, R. Paccagnella, G. Garrett-Grossman, A. Morrison, C. Fletcher and D. Kohlbrenner, &quot;Augury: Using data memory dependent prefetchers to leak data at rest,&quot; IEEE Symposium on Security and Privacy (SP), p. pp. 1518–1518, 2022.<br> [2]: M. Gross, N. Jacob, A. Zankl and G. Sigl, &quot;Breaking trustzone memory isolation through malicious hardware on a modern FPGA-SoC,&quot; in Proceedings of the 3rd ACM Workshop on Attacks and Solutions in Hardware Security Workshop, 2019.<br> [3]: &quot;Common Weakness Enumeration,&quot; [Online]. Available: <a href="https://cwe.mitre.org/" target="_blank" rel="noreferrer">https://cwe.mitre.org/</a>.<br> [4]: Y. Y. a. K. Falkner, &quot;FLUSH+ RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack,&quot; USENIX Security Symposium, p. 22–25, Vol. 1, 2014.<br> [5]: G. Dessouky, D. Gens, P. Haney, G. Persyn, A. Kanuparthi, H. Khattri, J. M. Fung, A.-R. Sadeghi and J. Rajendran, &quot;Hardfails: Insights into software-exploitable hardware bugs,&quot; in USENIX Security Symposium, 2019.<br> [6]: D. Jayasinghe, R. Ragel and D. Elkaduwe, &quot;Constant time encryption as a countermeasure against remote cache timing attacks,&quot; in IEEE 6th International Conference on Information and Automation for Sustainability (ICIAfS), 2012.<br> [7]: J. Kong, O. Aciicmez, J.-P. Seifert and H. Zhou, &quot;Deconstructing new cache designs for thwarting software cache-based side channel attacks,&quot; in Proceedings of the 2nd ACM workshop on Computer security architectures, 2008.<br> [8]: P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz and Y. Yarom, &quot;Spectre attacks: Exploiting speculative execution,&quot; arXiv preprint arXiv:1801.01203, 2018.<br> [9]: M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, S. Mangard, P. Kocher, D. Genkin, Y. Yarom and M. Hamburg, &quot;Meltdown,&quot; arXiv preprint arXiv:1801.01207, 2018.<br> [10]: C. Canella, D. Genkin, L. Giner, D. Gruss, M. Lipp, M. Minkin, D. Moghimi, F. Piessens, M. Schwarz, B. Sunar, J. Von Bulck and Y. Yarom, &quot;Fallout: Leaking Data on Meltdown-resistant CPUs,&quot; in Proc. ACM Conference on Computer and Communications Security (CCS), 2019.<br> [11]: M. Schwarz, M. Lipp, D. Moghimi, J. Van Bulck, J. Stecklina, T. Prescher and D. Gruss, &quot;ZombieLoad: Cross-privilege-boundary data sampling,&quot; arXiv preprint arXiv:1905.05726, 2019.<br> [12]: S. van Schaik, A. Milburn, S. Österlund, P. Frigo, G. Maisuradze, K. Razavi, H. Bos and C. Giuffrida, &quot;RIDL: Rogue In-Flight Data Load,&quot; in IEEE Symposium on Security and Privacy (S&amp;P), 2019.<br> [13]: V. Kiriansky and C. Waldspurger, &quot;Speculative buffer overflows: Attacks and defenses,&quot; arXiv preprint arXiv:1807.03757, 2018.<br> [14]: M. Behnia, P. Sahu, R. Paccagnella, J. Yu, Z. Zhao, X. Zou, T. Unterluggauer, J. Torrellas, C. Rozas, A. Morrison and others, &quot;Speculative interference attacks: Breaking invisible speculation schemes,&quot; arXiv preprint arXiv:2007.11818, 2020.<br> [15]: K. v. Gleissenthall, R. G. Kıcı, D. Stefan and R. Jhala, &quot;IODINE: Verifying Constant-Time Execution of Hardware,&quot; in 28th USENIX Security Symposium (USENIX Security 19), 2019.<br> [16]: J. Yu, M. Yan, A. Khyzha, A. Morrison, J. Torrellas and C. W. Fletcher, &quot;Speculative taint tracking (STT) a comprehensive protection for speculatively accessed data,&quot; in Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, 2019.<br> [17]: K. Loughlin, I. Neal, J. Ma, E. Tsai, O. Weisse, S. Narayanasamy and B. Kasikci, &quot;DOLMA: Securing Speculation with the Principle of Transient Non-Observability,&quot; in 30th USENIX Security Symposium (USENIX Security 21), 2021.<br> [18]: Y. Yarom, D. Genkin and N. Heninger, &quot;CacheBleed: a timing attack on OpenSSL constant-time RSA,&quot; Journal of Cryptographic Engineering, vol. 7, p. 99–112, 2017.<br> [19]: C. Percival, &quot;Cache missing for fun and profit,&quot; in BSDCan, 2005.<br> [20]: D. Gullasch, E. Bangerter and S. Krenn, &quot;Cache games–Bringing access-based cache attacks on AES to practice,&quot; in IEEE Symposium on Security and Privacy (SP), 2011.<br> [21]: A. Purnal, F. Turan and I. Verbauwhede, &quot;Prime+ Scope: Overcoming the Observer Effect for High-Precision Cache Contention Attacks,&quot; in Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security, 2021.<br> [22]: P. Pessl, D. Gruss, C. Maurice, M. Schwarz and S. Mangard, &quot;DRAMA: Exploiting DRAM Addressing for Cross-CPU Attacks,&quot; in 25th USENIX Security Symposium (USENIX Security 16), 2016.<br> [23]: O. Aciicmez and J.-P. Seifert, &quot;Cheap hardware parallelism implies cheap security,&quot; in Workshop on Fault Diagnosis and Tolerance in Cryptography (FDTC), 2007.<br> [24]: P. C. Kocher, J. Jaffe and B. Jun, &quot;Differential Power Analysis,&quot; Advances in Cryptology, pp. 388-397, 1999.<br> [25]: Y. Liu, L. Wei, Z. Zhou, K. Zhang, W. Xu and Q. Xu, &quot;On code execution tracking via power side-channel,&quot; Proceedings of the 2016 ACM SIGSAC conference on computer and communications security, p. 1019–1031, 2016.<br> [26]: O. Reparaz, B. Bilgin, S. Nikova, B. Gierlichs and I. Verbauwhede, &quot;Consolidating Masking,&quot; CRYPTO, 2015.<br> [27]: D. Jayasinghe, A. Ignjatovic, J. A. Ambrose, R. Ragel and S. Parameswaran, &quot;QuadSeal: Quadruple algorithmic symmetrizing countermeasure against power based side-channel attacks,&quot; International Conference on Compilers, Architecture and Synthesis for Embedded Systems (CASES), pp. 21-30, 2015.<br> [28]: V. Arribas, S. Nikova and V. Rijmen, &quot;VerMI: Verification Tool for Masked Implementations,&quot; IEEE International Conference on Electronics, Circuits and Systems (ICECS), pp. 381-384, 2018.<br> [29]: R. Bloem, H. Gross, R. Iusupov, B. Könighofer, S. Mangard and J. Winter, &quot;Fromal Verification of Masked Hardware Implementations in the Presence of Glitches,&quot; Annual International Conference on the Theory and Applications of Cryptographic Techniques, pp. 321-353, 2018.<br> [30]: ARM TrustZone Technology.<br> [31]: D. Lee, D. Kohlbrenner, S. Shinde, K. Asanović and D. Song, &quot;Keystone: An Open Framework for Architecting Trusted Execution Environments,&quot; in EUROSYS, 2020.<br> [32]: &quot;The seL4® Microkernel,&quot; [Online]. Available: <a href="https://sel4.systems/" target="_blank" rel="noreferrer">https://sel4.systems/</a>.<br> [33]: A. Ferraiuolo, M. Zhao, A. C. Myers and G. E. Suh, &quot;HyperFlow: A processor architecture for nonmalleable, timing-safe information flow security,&quot; in ACM SIGSAC Conf. on Computer &amp; Communications Security, 2018.<br> [34]: RISC-V Foundation, The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Version1.10, A. Waterman and K. Asanović, Eds., 2017.<br> [35]: R. Baranowski, M. A. Kochte and H.-J. Wunderlich, &quot;Reconfigurable Scan Networks: Modeling, Verification, and Optimal Pattern Generation,&quot; ACM Trans. Des. Autom. Electron. Syst., vol. 20, pp. 30:1-30:27, March 2015.<br> [36]: G. Cabodi, P. Camurati, F. Finocchiaro and D. Vendraminetto, &quot;Model Checking Speculation-Dependent Security Properties: Abstracting and Reducing Processor Models for Sound and Complete Verification,&quot; in Intl. Conf. on Codes, Cryptology, &amp; Information Security, 2019.<br> [37]: G. Cabodi, P. Camurati, S. F. Finocchiaro, F. Savarese and D. Vendraminetto, &quot;Embedded Systems Secure Path Verification at the HW/SW Interface,&quot; IEEE Design &amp; Test, vol. 34, p. 38–46, 2017.<br> [38]: P. Subramanyan and D. Arora, &quot;Formal verification of taint-propagation security properties in a commercial SoC design,&quot; in Design and Test In Europe (DATE), 2014.<br> [39]: M. R. Clarkson and F. B. Schneider, &quot;Hyperproperties,&quot; Journal of Computer Security, vol. 18, p. 1157–1210, 2010.<br> [40]: M. R. Fadiheh, D. Stoffel, C. Barrett, S. Mitra and W. Kunz, &quot;Processor Hardware Security Vulnerabilities and their Detection by Unique Program Execution Checking,&quot; in IEEE Design Automation and Test in Europe (DATE), 2019.<br> [41]: M. R. Fadiheh, A. Wezel, J. Mueller, J. Bormann, S. Ray, J. M. Fung, S. Mitra, D. Stoffel and W. Kunz, &quot;An Exhaustive Approach to Detecting Transient Execution Side Channels in RTL Designs of Processors,&quot; in preview of IEEE Transactions on Computers, 2022.<br> [42]: J. Müller, M. R. Fadiheh, A. L. Duque Anton, T. Eisenbarth, D. Stoffel and W. Kunz, &quot;A Formal Approach to Confidentiality Verification in SoCs at the Register Transfer Level,&quot; in IEEE/ACM Design Automation Conference (DAC), 2021.<br> [43]: M. Goli and R. Drechsler, &quot;Early SoCs Information Flow Policies Validation Using SystemC-Based Virtual Prototypes at the ESL,&quot; ACM Transactions on Embedded Computing Systems, <a href="https://doi.org/10.1145/3544780" target="_blank" rel="noreferrer">https://doi.org/10.1145/3544780</a>, 2022.<br> [44]: R. Guanciale, M. Balliu and M. Dam, &quot;InSpectre: Breaking and fixing microarchitectural vulnerabilities by formal analysis,&quot; in Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security, 2020.<br> [45]: S. A. Seshia and P. Subramanyan, &quot;UCLID5: Integrating modeling, verification, synthesis and learning,&quot; in 2018 16th ACM/IEEE International Conference on Formal Methods and Models for System Design (MEMOCODE), 2018.<br> [46]: C. Trippel, D. Lustig and M. Martonosi, &quot;CheckMate: Automated synthesis of hardware exploits and security litmus tests,&quot; in 2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), 2018.</p></div>',57),s=[o];function c(l,h,u,d,m,f){return t(),a("div",null,s)}const y=e(r,[["render",c]]);export{g as __pageData,y as default};
